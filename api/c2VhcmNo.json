[{"title":"面试题示例","date":"2019-10-15T09:01:33.665Z","updated":"2019-10-16T07:35:44.774Z","content":"打车公司一面\n打车时，可以打专车或者快车。任何车都有车牌号和名称。\n不同车价格不同，快车每公里1元，专车每公里2元。\n行程开始时，显示车辆信息。\n行程结束时，显示打车金额（假定行程5公里）。\n\n考察面向对象、继承、设计抽象（设计模式）的能力\n12345678910111213141516171819202122232425262728293031323334353637383940414243# 车辆信息class Car &#123;    constructor(number,name)&#123;        this.number = number        this.name = name    &#125;&#125;# 快车class Kuai extends Car &#123;    constructor(number,name,price)&#123;        super(number,name)        this.price = 1    &#125;&#125;# 专车class Zhuan extends Car  &#123;    constructor(number,name,price)&#123;        super(number,name)        this.price = 2    &#125;&#125;# 行程信息class Trip &#123;    constructor(car)&#123;        this.car = car    &#125;    start ()&#123;        console.log(`行程开始。车辆名称：$&#123;this.car.name&#125;的车牌号为：$&#123;this.car.number&#125;`)    &#125;    end ()&#123;        console.log(`行程结束。车辆名称：$&#123;this.car.name&#125;的打车金额为$&#123;this.car.price*5&#125;`)    &#125;&#125;let kuai = new Kuai(111,'桑塔纳')let zhaun = new Zhuan(222,'奔驰')let trip = new Trip(kuai)trip.start()trip.end()\n\n短视频公司三面\n某停车场，分三层，每层100个车位。\n每个车位都能监控到车辆的驶入和离开。\n车辆进入前，显示每层的空余车位数量。\n车辆进入时，摄像头可识别车牌号和时间。\n车辆出来时，出口显示器显示车牌号和停车时长。\n\n考察面向对象、继承、设计抽象（设计模式）的能力\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136# 出口显示器class Screen &#123;    show(number,time)&#123;        # console.log(`车辆驶出，车牌号为$&#123;number&#125;,停车时长$&#123;Date.now() - time&#125;`)    &#125;&#125;# 摄像头class Camera &#123;    // 摄像头可识别车牌号和时间    shot(car)&#123;        console.log(`车辆正在驶入，车牌号为$&#123;car.number&#125;`)        return &#123;            number:car.number,            initTime:Date.now()        &#125;    &#125;&#125;# 停车场class Part &#123;    constructor(floors)&#123;        this.camera = new Camera();        this.screen = new Screen();        this.floor = floors || [];        this.carList = &#123;&#125;;        this.floorNum = 0;        this.floorIndex = 0;    &#125;    // 车辆进入前    in(car)&#123;        const info = this.camera.shot(car)        if(this.restPlacesNum()&gt;0)&#123;            const place = this.floor[this.floorIndex].places[this.floorNum-1];            // 车辆进入时            place.in();            info.place = place;            this.carList[car.number] = info        &#125;            &#125;    // 车辆出来时    out(car)&#123;        let info = this.carList[car.number];        const place = info.place;        place.out();                // 出口显示器显示车牌号和停车时长        this.screen.show(car.number,info.initTime)    &#125;    // 停车场总剩余车位    restPlacesNum()&#123;        let count = 0;        this.floor.map((f,i)=&gt;&#123;            const placesNum = f.restPlacesNum(i)            if(placesNum&gt;0)&#123;                count += placesNum;                this.floorIndex = i;                this.floorNum = placesNum;                console.log(`第$&#123;i+1&#125;层，剩余车位$&#123;placesNum&#125;`)            &#125;else&#123;                console.log(`第$&#123;i+1&#125;层车位已满。`)            &#125;        &#125;)        return count;    &#125;&#125;# 楼层class Floor &#123;    constructor(whichFloor,places)&#123;        this.whichFloor = whichFloor;        this.places = places || [];    &#125;    // 当前楼层剩余车位    restPlacesNum()&#123;        let num = 0;        this.places.map((item)=&gt;&#123;            if(item.empty)&#123;                num++;            &#125;        &#125;)        return num    &#125;&#125;# 车位class Places  &#123;    constructor()&#123;        this.empty = true    &#125;    // 每个车位都能监控到车辆的驶入。    in()&#123;        this.empty = false    &#125;    // 每个车位都能监控到车辆的离开。    out()&#123;        this.empty = true    &#125;&#125;# 车class Car &#123;    constructor (number) &#123;        this.number = number;    &#125;&#125;# 实例化let floors = []for(let i=0; i&lt;3; i++)&#123;    let places = []    for(let j=0; j&lt;1; j++)&#123;        places[j] = new Places();    &#125;     floors[i] = new Floor(i+1,places)&#125;const part = new Part(floors);const car1 = new Car('111')const car2 = new Car('222')const car3 = new Car('333')# 方法调用part.in(car1)console.log(`\\n\\n`)part.in(car2)console.log(`\\n\\n`)part.out(car1)part.out(car2)console.log(`\\n\\n`)part.in(car3)","plink":"yibaobeiya.github.io/2019/10/15/设计模式/面试题/"},{"title":"五大设计原则（SOLID）","date":"2019-10-15T07:44:05.283Z","updated":"2019-10-15T09:55:20.696Z","content":"S：单一职责原则 （体现较多）\n一个程序只做好一件事。\n如果功能过于复杂就拆分开，每个部分保持独立。\n\nO：开放封闭原则 （体现较多）\n对扩展开放，对修改封闭。\n增加需求时，扩展新代码而不是修改已有代码。\n也是软件设计的终极目标。\n\n用promise来说明SO\n12345678910111213141516171819202122232425# 1.单一职责原则：每个then中的逻辑只做好一件事# 2.开放封闭原则：如果新增需求，扩展thenfunction loadImg(src)&#123;    return new Promise(function(resolve,reject)&#123;        let img = document.createElement('img');        img.onload = function()&#123;            resolve(img)        &#125;        img.onerror= function(err)&#123;            reject(err)        &#125;        img.src = src    &#125;)&#125;loadImg('https://www.gravatar.com/avatar/06818ca4361a28447cffdd2daaed2799?s=160').then(function(img)&#123;    console.log(img.width)    return img&#125;).then(function(img)&#123;    console.log(img.height)&#125;).catch(function(err)&#123;    //统一捕获异常    console.log(err)&#125;)\n\nL：李氏置换原则\n子类能覆盖父类，父类能出现的地方子类就能出现。\njs中使用较少（弱类型&amp;继承使用较少）。\n\nI：接口独立原则\n保持接口的单一独立，避免出现“胖接口”。\nJS中没有接口（typescript例外），使用较少。\n类似于单一职责原则，这里更关注接口\n\nD：依赖倒置原则\n面向接口编程，依赖于抽象而不依赖于具体。\n使用方法只关注接口而不关注具体类的实现。\nJS中使用较少（没有接口&amp;弱类型）。\n\n","plink":"yibaobeiya.github.io/2019/10/15/设计模式/设计原则/"},{"title":"JS - 面向对象","date":"2019-10-14T10:06:51.195Z","updated":"2019-10-15T09:10:15.030Z","content":"概念\n类，即模板\n对象（实例）\n\n面向对象三要素\n继承，子类继承父类\n封装 减少耦合，保护数据，接口的权限管理。\n多态，同一接口不同实现 保持子类开放性和灵活性，面向接口编程\n\n实例jQuery是怎么面向对象的123456789101112131415161718192021222324class jQuery &#123;    constructor(selector)&#123;        # Array.prototype.slice 方法将伪数组转为数组        let dom = Array.prototype.slice.call(document.querySelectorAll(selector))        let len = dom ? dom.length : 0                for ( let i = 0; i &lt; len; i++ ) &#123;            this [i]  = dom [i]        &#125;        this.length = len        this.selector = selector    &#125;    append (node) &#123;    &#125;    addClass (name) &#123;    &#125;    # 此处省略n个api...&#125;window.$ = function (selector) &#123;    return new jQuery(selector)&#125;\n\n面向对象的意义数据结构化\n","plink":"yibaobeiya.github.io/2019/10/14/js-面向对象/"},{"title":"JS 设计模式","date":"2019-10-12T02:57:12.535Z","updated":"2019-10-18T10:18:16.632Z","content":"概述js的设计模式总共有23种，总体来说设计模式分为三大类：\n1、创建型模式 共五种：工厂方法模式、抽象工厂模式、建造者模式、单例模式、原型模式。2、结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。3、行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n常用的设计模式工厂方法模式、单例模式、适配器模式、装饰器模式、代理模式、观察者模式、外观模式、迭代器模式、状态模式\n工厂方法模式介绍\n将 new 操作单独封装。\n遇到 new 时，就要考虑是否该使用工厂模式。\n符合开放封闭原则\n\n示例\n你去购买汉堡，直接点餐、取餐，不会自己亲手做。\n商店要封装做汉堡的工作，做好直接给顾客。\n\n123456789101112131415161718192021class Product &#123;    constructor(name)&#123;        this.name = name;    &#125;,    init()&#123;    &#125;    buy()&#123;        return this.name;    &#125;&#125;# //工厂class Store &#123;    create(name)&#123;        return new Product(name)    &#125;&#125;const store = new Store();  const product = store.create('干脆面')product.buy()\n\n场景\njQuery 实例$(‘div’)\n\n\nReact.createElement\n\n1234567891011class Vnode(tag, attrs, children) &#123;    # 省略内部代码...&#125;React.createElement = function(tag, attrs, children)&#123;    return new Vnode(tag, attrs, children)&#125;# 调用React.createElement('div',null,    React.createElement('img',&#123;src:'header.png'&#125;)    React.createElement('h3',null,'h3标题就是我'))\n\n\nvue 异步组件\n\n1234567Vue.component('component-name',function(resolve, reject)&#123;    setTimeout(function()&#123;        resolve(&#123;            template : '&lt;div&gt;I am async!&lt;/div&gt;'        &#125;)    &#125;,1000)&#125;)\n\n单例模式介绍\n系统中被唯一使用\n一个类只能初始化一个实例\n符合单一职责原则\n\n示例\n登陆框\n\n12345678910111213141516171819202122232425262728293031323334class LoginForm &#123;    constructor()&#123;        this.state = 'hide'    &#125;    show() &#123;        if(this.state==='show')&#123;            console.log('登陆框已经显示')            return;        &#125;        this.state = 'show';        console.log('show Success')    &#125;    hide()&#123;        if(this.state==='hide')&#123;            console.log('登陆框已经隐藏')            return;        &#125;        this.state = 'hide';        console.log('hide Success')    &#125;&#125;LoginForm.getInstance = (function()&#123;    let instance;    return function()&#123;        return instance?instance:instance = new LoginForm()    &#125;&#125;)();# 调用let login1 = LoginForm.getInstance()let login2 = LoginForm.getInstance()login1.show()login2.hide()login2.hide()console.log(login1===login2) //true\n\n场景\nvuex和redux中的store\n\n适配器模式介绍\n旧接口格式和使用者不兼容\n中间加一个适配转换接口\n将旧接口和使用者进行分离\n符合开放封闭原则\n\n示例\n插头的适配德国的插头在中国没办法使用，故需要将德国的插头转换（适配）为中国可使用的。\n\n12345678910111213141516171819# 德国的插头class GermanyPlug &#123;    getPlug()&#123;        return '德国专用插头'    &#125;&#125;# 中国的插头class chinaPlug &#123;    constructor ()&#123;        this.plug = new GermanyPlug()    &#125;    getPlug()&#123;        const info = this.plug.getPlug();        return `$&#123;info&#125; - 转换为 - 中国专用插头`    &#125;&#125;const plug = new chinaPlug();console.log(plug.getPlug())\n\n场景\n封装旧接口\nvue中的computed\n\n装饰器模式\nnpm install babel-plugin-transform-decorators-legacy –save-dev\n.babel文件中添加，”plugins”: [“transform-decorators-legacy”]\n\n介绍\n为对象添加新功能\n不改变其原有的结构和功能\n符合开放封闭原则\n\n示例1234567891011121314151617181920212223class Circle &#123;    draw() &#123;        console.log('画一个圆形')    &#125;&#125;class Decorator &#123;    constructor(circle) &#123;        this.circle = circle;    &#125;    draw() &#123;        this.circle.draw();        this.setBorderRed();    &#125;    setBorderRed() &#123;        console.log('设置红色边框')    &#125;&#125;# 调用let circle = new Circle();circle.draw()let decorator = new Decorator(circle)decorator.draw()\n\n场景\n装饰类\n\n1、简单的demo1\n123456789function testDec(target)&#123;    target.isDec = true&#125;@testDecclass Demo &#123;    //...&#125;console.log(Demo.isDec) //true\n\n2、可传参demo2\n1234567891011function testDec(isDec)&#123;    return function(target)&#123;        target.isDec = isDec;    &#125;&#125;@testDec(true)class Demo &#123;    //...&#125;console.log(Demo.isDec) //true\n\n3、mixin demo3\n1234567891011121314function mixins(...list)&#123;    return function(target)&#123;        Objext.assign(target.prototype,...list)    &#125;&#125;const Foo = &#123;    foo() &#123;        console.log('Foo')    &#125;&#125;@mixins(Foo)class Demo &#123;&#125;Demo.foo() //'foo'\n\n\n装饰方法\n\n1、设置方法为只读\n1234567891011121314function readonly(target,name,descriptor)&#123;    descriptor.writable = false; //设置不可写    return descriptor&#125;class Person &#123;    @readonly    name() &#123;        console.log('方法执行了')    &#125;&#125;const person = new Person();persoon.name();# //该行会报错person.name = function()&#123;&#125;\n\n2、打印日志\n12345678910111213141516function log(target,name,descriptor)&#123;    let oldValue = descriptor.value;    descriptor.value = function()&#123;        console.log(`calling $&#123;name&#125; width`,arguments);        return oldValue.apply(this,arguments)  //执行add方法    &#125;    return descriptor;&#125;class Math &#123;    @log    add(a,b) &#123;        return a + b    &#125;&#125;const math = new Math();console.log(math.add(2,4)) //calling add width &#123;...arguments&#125;  6\n\n\n引用第三方装饰器库npm install core-decorators –save\n\n123456789101112131415161718192021# 设置name为只读import &#123; readonly &#125; from 'core-decorators';class Person &#123;    @readonly  //设置name为只读    name() &#123;        console.log('方法执行了')    &#125;&#125;const person = new Person();persoon.name();# deprecate会在控制台告诉用户name的api已经弃用import &#123; deprecate &#125; from 'core-decorators';class Person &#123;    @deprecate('即将废弃',&#123;url:'www.baidu.com'&#125;)     name() &#123;        console.log('方法执行了')    &#125;&#125;const person = new Person();persoon.name();\n\n代理模式介绍\n使用者无权访问目标对象\n中间加代理，通过代理做授权和控制\n代理类和目标分离，隔离开目标类和使用者\n符合开放封闭原则\n\n场景\n网页事件代理(事件委托)\n\n12345ul.onclick = function(e)&#123;    if(e.target.nodeName === 'LI')&#123;        # do something...    &#125;&#125;\n\n\nJquery $.proxy\n\n123456$('#div').click(function()&#123;    setTimeout($.proxy(function()&#123;        # this符合预期        console.log($(this))    &#125;,this),1000)&#125;)\n\n\nES6 Proxy某个品牌商想找某个明星代言，明星已将这些细节交给经纪人处理，所以需要品牌商和明星经纪人直接洽谈。\n\n12345678910111213141516171819202122232425262728293031323334353637383940# 明星let star = &#123;    name:'小丸子',    age:'18',    phone:'17777777777'&#125;# 经纪人let agent = new Proxy(star,&#123;    get:function (target, key)&#123;        if(key ===  'phone')&#123;            # 返回经纪人自己的手机号            return 'agent：18888888888'        &#125;        if(key === 'price')&#123;            # 明星不报价，返回经纪人的报价            return '12000'        &#125;        return target[key]    &#125;,    set:function (target, key, val)&#123;        # 不满意价格向经纪人讲价        if(key === 'customPrice')&#123;            if(val &lt; 10000)&#123;                throw new Error('价格太低，拒绝讲价')            &#125;else&#123;                # 讲价成功                target[key] = val                return true;            &#125;        &#125;    &#125;&#125;)# 调用console.log(agent.name)console.log(agent.phone)console.log(agent.price)agent.customPrice = 100000 console.log(agent.customPrice)agent.customPrice = 1000  //价格太低，拒绝讲价\n\n观察者模式介绍\n发布&amp;订阅\n一对多\n主题和观察者分离，不是主动触发而是被动监听，两者解耦\n符合开放封闭原则\n\n示例12345678910111213141516171819202122232425262728293031323334353637383940# 主题，保存状态，状态变化之后触发所有观察者对象class Subject &#123;    constructor()&#123;        this.state = 0;        this.observers = [];    &#125;    getState()&#123;        return this.state    &#125;    setState(state)&#123;        this.state = state;        this.notifyAllObservers()    &#125;    notifyAllObservers()&#123;        this.observers.forEach(observer=&gt;&#123;            observer.update();        &#125;)    &#125;    attach(observer)&#123;        this.observers.push(observer);    &#125;&#125;# 观察者class Observer &#123;    constructor(name,subject)&#123;        this.name = name;        this.subject = subject;         this.subject.attach(this);    &#125;    update()&#123;        console.log(`$&#123;this.name&#125; update，state：$&#123;this.subject.state&#125;`)    &#125;&#125;# 调用const subject = new Subject();const observer1 = new Observer('observer1',subject);const observer2 = new Observer('observer2',subject);subject.setState(1)subject.setState(2)\n\n场景\n网页事件绑定所有的事件监听都属于观察者模式\n\n123456&lt;button id=\"btn1\"&gt;&lt;/button&gt;&lt;script&gt;    $('#btn1').click(function()&#123; console.log(1) &#125;)    $('#btn1').click(function()&#123; console.log(2) &#125;)    $('#btn1').click(function()&#123; console.log(3) &#125;)&lt;/script&gt;\n\n\nPromise\n\n12345678910111213141516171819202122function loadImg(src)&#123;    return new Promise(function(resolve,reject)&#123;        let img = document.createElement('img');        img.onload = function()&#123;            resolve(img)        &#125;        img.onerror= function(err)&#123;            reject(err)        &#125;        img.src = src    &#125;)&#125;loadImg('https://www.gravatar.com/avatar/06818ca4361a28447cffdd2daaed2799?s=160').then(function(img)&#123;    console.log(img.width)    return img&#125;).then(function(img)&#123;    console.log(img.height)&#125;).catch(function(err)&#123;    //统一捕获异常    console.log(err)&#125;)\n\n\njQuery callbacks  jquery底层代码演示\n\n123456789var callbacks = $.Callbacks()callbacks.add(function(info)&#123;    console.log('fn1',info)&#125;)callbacks.add(function(info)&#123;    console.log('fn2',info)&#125;)callbacks.fire('gogogo')callbacks.fire('fire')\n\n\nnodejs\n\n1234567891011121314151617181920212223242526272829303132# 自定义事件const EventEmitter = require('events').EventEmitter;# demo1const e = new EventEmitter();e.on('some',(res)=&gt;&#123;    console.log('1.监听some事件',res)&#125;)e.on('some',(res)=&gt;&#123;    console.log('2.监听some事件',res)&#125;)e.emit('some',&#123;&#125;)# demo2 任何构造函数都可以继承 EventEmitter 的 on emit 方法class Dog extends EventEmitter &#123;&#125;var simon = new Dog()simon.on('bark',function()&#123;    console.log('bark 事件被触发了')&#125;)simon.emit('bark')# demo3 stream流操作var fs = require('fs');var readStream = fs.createReadStream('1.txt') // 读取文件的streamvar length = 0;readStream.on('data',function(chunk)&#123;    length += chunk.toString().length;&#125;)readStream.on('end',function()&#123;    console.log('读取结束',length)&#125;)\n\n其他场景\nnodejs 中处理http请求；多进程通讯\nvue和react组件生命周期的触发\nvue watch\n\n外观模式介绍\n为子系统中的一组接口提供了一个高层接口\n使用者使用这个高层接口\n不符合单一职责原则和开放封闭原则，因此谨慎使用不可滥用\n符合接口独立原则\n\n示例12345678910function bindEvent(elem,type,selector,fn)&#123;    if(fn==null)&#123;        fn = selector        selector = null    &#125;    # do something...&#125;# 调用bindEvent(elem,'click','#div',fn)bindEvent(elem,'click',fn)\n\n迭代器模式介绍\n顺序访问一个集合\n使用者无需知道集合的内部结构（封装）\n迭代器对象和目标对象分离\n迭代器将使用者与目标对象隔离开\n\n示例123456789101112131415161718192021222324252627282930313233# 生成器class Iterator &#123;    constructor(container) &#123;        this.list = container.list;        this.index = 0;    &#125;    next()&#123;        if(this.hasNext())&#123;            return this.list[this.index++];        &#125;        return null;    &#125;    hasNext()&#123;        return !(this.index&gt;=this.list.length)    &#125;&#125;class Container &#123;    constructor(list)&#123;        this.list = list;    &#125;    # 生成遍历器    getIterator()&#123;        return new Iterator(this)    &#125;&#125;# 调用const arr = [1,2,3,4]const container = new Container(arr);const Iterator = container.getIterator();while(Iterator.hasNext())&#123;    console.log(Iterator.next())&#125;\n\n场景\njQuery eacharray.each()，nodeList.each()，$(‘div’).each()\n\nES6 Iterator\n\n\n\n为何存在?ES6 语法中，有序集合的数据类型已经有很多，Array Map Set String RtpedArray arguments NodeList，需要有一个统一的遍历接口来遍历所有的数据类型（注意，object不是有序集合，可以使用map代替）\nIterator 是什么?以上数据类型，都有Symbol.iterator属性。属性值是函数，执行函数返回一个迭代器。这个迭代器就有next方法可顺序迭代子元素。可运行Array,prototype[Symbol.iterator]来测试\n\n123456789101112131415161718192021# 自己封装遍历器function each(data)&#123;    let iterator = data[Symbol.iterator]();    let item = &#123;done:false&#125;    while(!item.done)&#123;        item = iterator.next();        if(!item.done)&#123;            console.log(item)        &#125;    &#125;&#125;# ES6提供遍历器 for offunction each(data)&#123;    for(let item of data)&#123;    &#125;&#125;# 调用each(nodeList)each(arr)\n\n\nGenerator 函数\n\n状态模式介绍\n一个对象有状态变化\n每次状态变化都会触发一个逻辑\n不能总是用 if…else来控制\n将状态对象和主体对象分离，状态的变化逻辑单独处理\n符合开放封闭原则\n\n示例\n交通信号灯的变化123456789101112131415161718192021222324252627282930313233# 状态class State &#123;    constructor(color)&#123;        this.color = color;    &#125;    handle(context)&#123;        context.setState(this)    &#125;&#125;# 主体class Context &#123;    constructor()&#123;        this.state = null;    &#125;    getState()&#123;        return this.state;    &#125;    setState(state)&#123;        this.state = state    &#125;&#125;const context = new Context();const green = new State('green')const yellow = new State('yellow')const black = new State('black')green.handle(context);console.log(context.getState())yellow.handle(context);console.log(context.getState())black.handle(context);console.log(context.getState())\n\n\n\n场景\n有限状态机  有限个状态，以及在这些状态之间的变化，如交通信号灯，使用开源lib:javascript-state-machine，(收藏和取消收藏)\n\n\n写一个简单的Promise  Promise就是一个有限状态机1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 利用第三方lib手写一个简单的Promise// 1.创建状态机模型import StateMachine from 'javascript-state-machine';let fsm = new StateMachine(&#123;    init:'pending',    transitions: [        &#123;            name:'resolve',            form:'pending',            to:'fullfilled'        &#125;,        &#123;            name:'reject',            form:'pending',            to:'rejected'        &#125;    ],    methods: &#123;        // state 当前状态机的实例        // data 执行resolve传的参数        onResolve(state, data)&#123;            data.successList.forEach( fn =&gt; fn())        &#125;,        onReject(state,  data)&#123;            data.failList.forEach( fn =&gt; fn())        &#125;    &#125;&#125;)// 2.定义promise类class MyPromise &#123;    constructor(fn)&#123;        this.successList = []        this.failList = []        fn(()=&gt;&#123;            // resolve函数            fsm.resolve(this)        &#125;,()=&gt;&#123;            // reject函数            fsm.reject(this)        &#125;)    &#125;    then(successFn, failFn)&#123;       this.successList.push(successFn)       this.failList.push(failFn)    &#125;&#125;# 模拟调用new MyPromise().then(()=&gt;&#123;    console.log('success')&#125;,()=&gt;&#123;    console.log('fail')&#125;)\n\n\n\n不常用的设计模式总结代理模式和适配器模式的区别\n适配器模式  提供一个不同的接口（如不同版本的插头）\n代理模式  提供一模一样的接口\n\n代理模式和装饰器模式的区别\n装饰器模式  扩展功能，原有功能不变且可直接使用\n代理模式  显示原有功能，但是经过限制或者阉割之后的\n\n","plink":"yibaobeiya.github.io/2019/10/12/设计模式/设计模式/"}]