[{"title":"面试题示例","date":"2019-10-15T09:01:33.665Z","updated":"2019-10-16T07:35:44.774Z","content":"打车公司一面\n打车时，可以打专车或者快车。任何车都有车牌号和名称。\n不同车价格不同，快车每公里1元，专车每公里2元。\n行程开始时，显示车辆信息。\n行程结束时，显示打车金额（假定行程5公里）。\n\n考察面向对象、继承、设计抽象（设计模式）的能力\n12345678910111213141516171819202122232425262728293031323334353637383940414243# 车辆信息class Car &#123;    constructor(number,name)&#123;        this.number = number        this.name = name    &#125;&#125;# 快车class Kuai extends Car &#123;    constructor(number,name,price)&#123;        super(number,name)        this.price = 1    &#125;&#125;# 专车class Zhuan extends Car  &#123;    constructor(number,name,price)&#123;        super(number,name)        this.price = 2    &#125;&#125;# 行程信息class Trip &#123;    constructor(car)&#123;        this.car = car    &#125;    start ()&#123;        console.log(`行程开始。车辆名称：$&#123;this.car.name&#125;的车牌号为：$&#123;this.car.number&#125;`)    &#125;    end ()&#123;        console.log(`行程结束。车辆名称：$&#123;this.car.name&#125;的打车金额为$&#123;this.car.price*5&#125;`)    &#125;&#125;let kuai = new Kuai(111,'桑塔纳')let zhaun = new Zhuan(222,'奔驰')let trip = new Trip(kuai)trip.start()trip.end()\n\n短视频公司三面\n某停车场，分三层，每层100个车位。\n每个车位都能监控到车辆的驶入和离开。\n车辆进入前，显示每层的空余车位数量。\n车辆进入时，摄像头可识别车牌号和时间。\n车辆出来时，出口显示器显示车牌号和停车时长。\n\n考察面向对象、继承、设计抽象（设计模式）的能力\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136# 出口显示器class Screen &#123;    show(number,time)&#123;        # console.log(`车辆驶出，车牌号为$&#123;number&#125;,停车时长$&#123;Date.now() - time&#125;`)    &#125;&#125;# 摄像头class Camera &#123;    // 摄像头可识别车牌号和时间    shot(car)&#123;        console.log(`车辆正在驶入，车牌号为$&#123;car.number&#125;`)        return &#123;            number:car.number,            initTime:Date.now()        &#125;    &#125;&#125;# 停车场class Part &#123;    constructor(floors)&#123;        this.camera = new Camera();        this.screen = new Screen();        this.floor = floors || [];        this.carList = &#123;&#125;;        this.floorNum = 0;        this.floorIndex = 0;    &#125;    // 车辆进入前    in(car)&#123;        const info = this.camera.shot(car)        if(this.restPlacesNum()&gt;0)&#123;            const place = this.floor[this.floorIndex].places[this.floorNum-1];            // 车辆进入时            place.in();            info.place = place;            this.carList[car.number] = info        &#125;            &#125;    // 车辆出来时    out(car)&#123;        let info = this.carList[car.number];        const place = info.place;        place.out();                // 出口显示器显示车牌号和停车时长        this.screen.show(car.number,info.initTime)    &#125;    // 停车场总剩余车位    restPlacesNum()&#123;        let count = 0;        this.floor.map((f,i)=&gt;&#123;            const placesNum = f.restPlacesNum(i)            if(placesNum&gt;0)&#123;                count += placesNum;                this.floorIndex = i;                this.floorNum = placesNum;                console.log(`第$&#123;i+1&#125;层，剩余车位$&#123;placesNum&#125;`)            &#125;else&#123;                console.log(`第$&#123;i+1&#125;层车位已满。`)            &#125;        &#125;)        return count;    &#125;&#125;# 楼层class Floor &#123;    constructor(whichFloor,places)&#123;        this.whichFloor = whichFloor;        this.places = places || [];    &#125;    // 当前楼层剩余车位    restPlacesNum()&#123;        let num = 0;        this.places.map((item)=&gt;&#123;            if(item.empty)&#123;                num++;            &#125;        &#125;)        return num    &#125;&#125;# 车位class Places  &#123;    constructor()&#123;        this.empty = true    &#125;    // 每个车位都能监控到车辆的驶入。    in()&#123;        this.empty = false    &#125;    // 每个车位都能监控到车辆的离开。    out()&#123;        this.empty = true    &#125;&#125;# 车class Car &#123;    constructor (number) &#123;        this.number = number;    &#125;&#125;# 实例化let floors = []for(let i=0; i&lt;3; i++)&#123;    let places = []    for(let j=0; j&lt;1; j++)&#123;        places[j] = new Places();    &#125;     floors[i] = new Floor(i+1,places)&#125;const part = new Part(floors);const car1 = new Car('111')const car2 = new Car('222')const car3 = new Car('333')# 方法调用part.in(car1)console.log(`\\n\\n`)part.in(car2)console.log(`\\n\\n`)part.out(car1)part.out(car2)console.log(`\\n\\n`)part.in(car3)","plink":"yibaobeiya.github.io/2019/10/15/设计模式/面试题/"},{"title":"五大设计原则（SOLID）","date":"2019-10-15T07:44:05.283Z","updated":"2019-10-15T09:55:20.696Z","content":"S：单一职责原则 （体现较多）\n一个程序只做好一件事。\n如果功能过于复杂就拆分开，每个部分保持独立。\n\nO：开放封闭原则 （体现较多）\n对扩展开放，对修改封闭。\n增加需求时，扩展新代码而不是修改已有代码。\n也是软件设计的终极目标。\n\n用promise来说明SO\n12345678910111213141516171819202122232425# 1.单一职责原则：每个then中的逻辑只做好一件事# 2.开放封闭原则：如果新增需求，扩展thenfunction loadImg(src)&#123;    return new Promise(function(resolve,reject)&#123;        let img = document.createElement('img');        img.onload = function()&#123;            resolve(img)        &#125;        img.onerror= function(err)&#123;            reject(err)        &#125;        img.src = src    &#125;)&#125;loadImg('https://www.gravatar.com/avatar/06818ca4361a28447cffdd2daaed2799?s=160').then(function(img)&#123;    console.log(img.width)    return img&#125;).then(function(img)&#123;    console.log(img.height)&#125;).catch(function(err)&#123;    //统一捕获异常    console.log(err)&#125;)\n\nL：李氏置换原则\n子类能覆盖父类，父类能出现的地方子类就能出现。\njs中使用较少（弱类型&amp;继承使用较少）。\n\nI：接口独立原则\n保持接口的单一独立，避免出现“胖接口”。\nJS中没有接口（typescript例外），使用较少。\n类似于单一职责原则，这里更关注接口\n\nD：依赖倒置原则\n面向接口编程，依赖于抽象而不依赖于具体。\n使用方法只关注接口而不关注具体类的实现。\nJS中使用较少（没有接口&amp;弱类型）。\n\n","plink":"yibaobeiya.github.io/2019/10/15/设计模式/设计原则/"},{"title":"JS - 面向对象","date":"2019-10-14T10:06:51.195Z","updated":"2019-10-15T09:10:15.030Z","content":"概念\n类，即模板\n对象（实例）\n\n面向对象三要素\n继承，子类继承父类\n封装 减少耦合，保护数据，接口的权限管理。\n多态，同一接口不同实现 保持子类开放性和灵活性，面向接口编程\n\n实例jQuery是怎么面向对象的123456789101112131415161718192021222324class jQuery &#123;    constructor(selector)&#123;        # Array.prototype.slice 方法将伪数组转为数组        let dom = Array.prototype.slice.call(document.querySelectorAll(selector))        let len = dom ? dom.length : 0                for ( let i = 0; i &lt; len; i++ ) &#123;            this [i]  = dom [i]        &#125;        this.length = len        this.selector = selector    &#125;    append (node) &#123;    &#125;    addClass (name) &#123;    &#125;    # 此处省略n个api...&#125;window.$ = function (selector) &#123;    return new jQuery(selector)&#125;\n\n面向对象的意义数据结构化\n","plink":"yibaobeiya.github.io/2019/10/14/js-面向对象/"},{"title":"JS 设计模式","date":"2019-10-12T02:57:12.535Z","updated":"2019-10-17T10:14:00.075Z","content":"概述js的设计模式总共有23种，总体来说设计模式分为三大类：\n1、创建型模式 共五种：工厂方法模式、抽象工厂模式、建造者模式、单例模式、原型模式。2、结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。3、行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n常用的设计模式工厂方法模式、单例模式、适配器模式、装饰器模式、代理模式\n工厂方法模式介绍\n将 new 操作单独封装。\n遇到 new 时，就要考虑是否该使用工厂模式。\n符合开放封闭原则\n\n示例\n你去购买汉堡，直接点餐、取餐，不会自己亲手做。\n商店要封装做汉堡的工作，做好直接给顾客。\n\n123456789101112131415161718192021class Product &#123;    constructor(name)&#123;        this.name = name;    &#125;,    init()&#123;    &#125;    buy()&#123;        return this.name;    &#125;&#125;# //工厂class Store &#123;    create(name)&#123;        return new Product(name)    &#125;&#125;const store = new Store();  const product = store.create('干脆面')product.buy()\n\n场景\njQuery 实例$(‘div’)\n\n\nReact.createElement\n\n1234567891011class Vnode(tag, attrs, children) &#123;    # 省略内部代码...&#125;React.createElement = function(tag, attrs, children)&#123;    return new Vnode(tag, attrs, children)&#125;# 调用React.createElement('div',null,    React.createElement('img',&#123;src:'header.png'&#125;)    React.createElement('h3',null,'h3标题就是我'))\n\n\nvue 异步组件\n\n1234567Vue.component('component-name',function(resolve, reject)&#123;    setTimeout(function()&#123;        resolve(&#123;            template : '&lt;div&gt;I am async!&lt;/div&gt;'        &#125;)    &#125;,1000)&#125;)\n\n单例模式介绍\n系统中被唯一使用\n一个类只能初始化一个实例\n符合单一职责原则\n\n示例\n登陆框\n\n12345678910111213141516171819202122232425262728293031323334class LoginForm &#123;    constructor()&#123;        this.state = 'hide'    &#125;    show() &#123;        if(this.state==='show')&#123;            console.log('登陆框已经显示')            return;        &#125;        this.state = 'show';        console.log('show Success')    &#125;    hide()&#123;        if(this.state==='hide')&#123;            console.log('登陆框已经隐藏')            return;        &#125;        this.state = 'hide';        console.log('hide Success')    &#125;&#125;LoginForm.getInstance = (function()&#123;    let instance;    return function()&#123;        return instance?instance:instance = new LoginForm()    &#125;&#125;)();# 调用let login1 = LoginForm.getInstance()let login2 = LoginForm.getInstance()login1.show()login2.hide()login2.hide()console.log(login1===login2) //true\n\n场景\nvuex和redux中的store\n\n适配器模式介绍\n旧接口格式和使用者不兼容\n中间加一个适配转换接口\n将旧接口和使用者进行分离\n符合开放封闭原则\n\n示例\n插头的适配德国的插头在中国没办法使用，故需要将德国的插头转换（适配）为中国可使用的。\n\n12345678910111213141516171819# 德国的插头class GermanyPlug &#123;    getPlug()&#123;        return '德国专用插头'    &#125;&#125;# 中国的插头class chinaPlug &#123;    constructor ()&#123;        this.plug = new GermanyPlug()    &#125;    getPlug()&#123;        const info = this.plug.getPlug();        return `$&#123;info&#125; - 转换为 - 中国专用插头`    &#125;&#125;const plug = new chinaPlug();console.log(plug.getPlug())\n\n场景\n封装旧接口\nvue中的computed\n\n装饰器模式\nnpm install babel-plugin-transform-decorators-legacy –save-dev\n.babel文件中添加，”plugins”: [“transform-decorators-legacy”]\n\n介绍\n为对象添加新功能\n不改变其原有的结构和功能\n符合开放封闭原则\n\n示例1234567891011121314151617181920212223class Circle &#123;    draw() &#123;        console.log('画一个圆形')    &#125;&#125;class Decorator &#123;    constructor(circle) &#123;        this.circle = circle;    &#125;    draw() &#123;        this.circle.draw();        this.setBorderRed();    &#125;    setBorderRed() &#123;        console.log('设置红色边框')    &#125;&#125;# 调用let circle = new Circle();circle.draw()let decorator = new Decorator(circle)decorator.draw()\n\n场景\n装饰类\n\n1、简单的demo1\n123456789function testDec(target)&#123;    target.isDec = true&#125;@testDecclass Demo &#123;    //...&#125;console.log(Demo.isDec) //true\n\n2、可传参demo2\n1234567891011function testDec(isDec)&#123;    return function(target)&#123;        target.isDec = isDec;    &#125;&#125;@testDec(true)class Demo &#123;    //...&#125;console.log(Demo.isDec) //true\n\n3、mixin demo3\n1234567891011121314function mixins(...list)&#123;    return function(target)&#123;        Objext.assign(target.prototype,...list)    &#125;&#125;const Foo = &#123;    foo() &#123;        console.log('Foo')    &#125;&#125;@mixins(Foo)class Demo &#123;&#125;Demo.foo() //'foo'\n\n\n装饰方法\n\n1、设置方法为只读\n1234567891011121314function readonly(target,name,descriptor)&#123;    descriptor.writable = false; //设置不可写    return descriptor&#125;class Person &#123;    @readonly    name() &#123;        console.log('方法执行了')    &#125;&#125;const person = new Person();persoon.name();# //该行会报错person.name = function()&#123;&#125;\n\n2、打印日志\n12345678910111213141516function log(target,name,descriptor)&#123;    let oldValue = descriptor.value;    descriptor.value = function()&#123;        console.log(`calling $&#123;name&#125; width`,arguments);        return oldValue.apply(this,arguments)  //执行add方法    &#125;    return descriptor;&#125;class Math &#123;    @log    add(a,b) &#123;        return a + b    &#125;&#125;const math = new Math();console.log(math.add(2,4)) //calling add width &#123;...arguments&#125;  6\n\n\n引用第三方装饰器库npm install core-decorators –save\n\n123456789101112131415161718192021# 设置name为只读import &#123; readonly &#125; from 'core-decorators';class Person &#123;    @readonly  //设置name为只读    name() &#123;        console.log('方法执行了')    &#125;&#125;const person = new Person();persoon.name();# deprecate会在控制台告诉用户name的api已经弃用import &#123; deprecate &#125; from 'core-decorators';class Person &#123;    @deprecate('即将废弃',&#123;url:'www.baidu.com'&#125;)     name() &#123;        console.log('方法执行了')    &#125;&#125;const person = new Person();persoon.name();\n\n代理模式介绍示例\n科学上网\n明星经纪人\n\n场景\n网页事件代理(事件委托)\n\n12345ul.onclick = function(e)&#123;    if(e.target.nodeName === 'LI')&#123;        # do something...    &#125;&#125;\n\n\nJquery $.proxy\n\n123456$('#div').click(function()&#123;    setTimeout($.proxy(function()&#123;        # this符合预期        console.log($(this))    &#125;,this),1000)&#125;)\n\n\nes6 Proxy\n\n","plink":"yibaobeiya.github.io/2019/10/12/设计模式/设计模式/"}]