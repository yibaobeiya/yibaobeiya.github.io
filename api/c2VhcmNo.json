[{"title":"面试题示例","date":"2019-10-15T09:01:33.665Z","updated":"2019-10-16T07:35:44.774Z","content":"打车公司一面\n打车时，可以打专车或者快车。任何车都有车牌号和名称。\n不同车价格不同，快车每公里1元，专车每公里2元。\n行程开始时，显示车辆信息。\n行程结束时，显示打车金额（假定行程5公里）。\n\n考察面向对象、继承、设计抽象（设计模式）的能力\n12345678910111213141516171819202122232425262728293031323334353637383940414243# 车辆信息class Car &#123;    constructor(number,name)&#123;        this.number = number        this.name = name    &#125;&#125;# 快车class Kuai extends Car &#123;    constructor(number,name,price)&#123;        super(number,name)        this.price = 1    &#125;&#125;# 专车class Zhuan extends Car  &#123;    constructor(number,name,price)&#123;        super(number,name)        this.price = 2    &#125;&#125;# 行程信息class Trip &#123;    constructor(car)&#123;        this.car = car    &#125;    start ()&#123;        console.log(`行程开始。车辆名称：$&#123;this.car.name&#125;的车牌号为：$&#123;this.car.number&#125;`)    &#125;    end ()&#123;        console.log(`行程结束。车辆名称：$&#123;this.car.name&#125;的打车金额为$&#123;this.car.price*5&#125;`)    &#125;&#125;let kuai = new Kuai(111,'桑塔纳')let zhaun = new Zhuan(222,'奔驰')let trip = new Trip(kuai)trip.start()trip.end()\n\n短视频公司三面\n某停车场，分三层，每层100个车位。\n每个车位都能监控到车辆的驶入和离开。\n车辆进入前，显示每层的空余车位数量。\n车辆进入时，摄像头可识别车牌号和时间。\n车辆出来时，出口显示器显示车牌号和停车时长。\n\n考察面向对象、继承、设计抽象（设计模式）的能力\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136# 出口显示器class Screen &#123;    show(number,time)&#123;        # console.log(`车辆驶出，车牌号为$&#123;number&#125;,停车时长$&#123;Date.now() - time&#125;`)    &#125;&#125;# 摄像头class Camera &#123;    // 摄像头可识别车牌号和时间    shot(car)&#123;        console.log(`车辆正在驶入，车牌号为$&#123;car.number&#125;`)        return &#123;            number:car.number,            initTime:Date.now()        &#125;    &#125;&#125;# 停车场class Part &#123;    constructor(floors)&#123;        this.camera = new Camera();        this.screen = new Screen();        this.floor = floors || [];        this.carList = &#123;&#125;;        this.floorNum = 0;        this.floorIndex = 0;    &#125;    // 车辆进入前    in(car)&#123;        const info = this.camera.shot(car)        if(this.restPlacesNum()&gt;0)&#123;            const place = this.floor[this.floorIndex].places[this.floorNum-1];            // 车辆进入时            place.in();            info.place = place;            this.carList[car.number] = info        &#125;            &#125;    // 车辆出来时    out(car)&#123;        let info = this.carList[car.number];        const place = info.place;        place.out();                // 出口显示器显示车牌号和停车时长        this.screen.show(car.number,info.initTime)    &#125;    // 停车场总剩余车位    restPlacesNum()&#123;        let count = 0;        this.floor.map((f,i)=&gt;&#123;            const placesNum = f.restPlacesNum(i)            if(placesNum&gt;0)&#123;                count += placesNum;                this.floorIndex = i;                this.floorNum = placesNum;                console.log(`第$&#123;i+1&#125;层，剩余车位$&#123;placesNum&#125;`)            &#125;else&#123;                console.log(`第$&#123;i+1&#125;层车位已满。`)            &#125;        &#125;)        return count;    &#125;&#125;# 楼层class Floor &#123;    constructor(whichFloor,places)&#123;        this.whichFloor = whichFloor;        this.places = places || [];    &#125;    // 当前楼层剩余车位    restPlacesNum()&#123;        let num = 0;        this.places.map((item)=&gt;&#123;            if(item.empty)&#123;                num++;            &#125;        &#125;)        return num    &#125;&#125;# 车位class Places  &#123;    constructor()&#123;        this.empty = true    &#125;    // 每个车位都能监控到车辆的驶入。    in()&#123;        this.empty = false    &#125;    // 每个车位都能监控到车辆的离开。    out()&#123;        this.empty = true    &#125;&#125;# 车class Car &#123;    constructor (number) &#123;        this.number = number;    &#125;&#125;# 实例化let floors = []for(let i=0; i&lt;3; i++)&#123;    let places = []    for(let j=0; j&lt;1; j++)&#123;        places[j] = new Places();    &#125;     floors[i] = new Floor(i+1,places)&#125;const part = new Part(floors);const car1 = new Car('111')const car2 = new Car('222')const car3 = new Car('333')# 方法调用part.in(car1)console.log(`\\n\\n`)part.in(car2)console.log(`\\n\\n`)part.out(car1)part.out(car2)console.log(`\\n\\n`)part.in(car3)","plink":"yibaobeiya.github.io/2019/10/15/设计模式/面试题/"},{"title":"五大设计原则（SOLID）","date":"2019-10-15T07:44:05.283Z","updated":"2019-10-15T09:55:20.696Z","content":"S：单一职责原则 （体现较多）\n一个程序只做好一件事。\n如果功能过于复杂就拆分开，每个部分保持独立。\n\nO：开放封闭原则 （体现较多）\n对扩展开放，对修改封闭。\n增加需求时，扩展新代码而不是修改已有代码。\n也是软件设计的终极目标。\n\n用promise来说明SO\n12345678910111213141516171819202122232425# 1.单一职责原则：每个then中的逻辑只做好一件事# 2.开放封闭原则：如果新增需求，扩展thenfunction loadImg(src)&#123;    return new Promise(function(resolve,reject)&#123;        let img = document.createElement('img');        img.onload = function()&#123;            resolve(img)        &#125;        img.onerror= function(err)&#123;            reject(err)        &#125;        img.src = src    &#125;)&#125;loadImg('https://www.gravatar.com/avatar/06818ca4361a28447cffdd2daaed2799?s=160').then(function(img)&#123;    console.log(img.width)    return img&#125;).then(function(img)&#123;    console.log(img.height)&#125;).catch(function(err)&#123;    //统一捕获异常    console.log(err)&#125;)\n\nL：李氏置换原则\n子类能覆盖父类，父类能出现的地方子类就能出现。\njs中使用较少（弱类型&amp;继承使用较少）。\n\nI：接口独立原则\n保持接口的单一独立，避免出现“胖接口”。\nJS中没有接口（typescript例外），使用较少。\n类似于单一职责原则，这里更关注接口\n\nD：依赖倒置原则\n面向接口编程，依赖于抽象而不依赖于具体。\n使用方法只关注接口而不关注具体类的实现。\nJS中使用较少（没有接口&amp;弱类型）。\n\n","plink":"yibaobeiya.github.io/2019/10/15/设计模式/设计原则/"},{"title":"JS - 面向对象","date":"2019-10-14T10:06:51.195Z","updated":"2019-10-15T09:10:15.030Z","content":"概念\n类，即模板\n对象（实例）\n\n面向对象三要素\n继承，子类继承父类\n封装 减少耦合，保护数据，接口的权限管理。\n多态，同一接口不同实现 保持子类开放性和灵活性，面向接口编程\n\n实例jQuery是怎么面向对象的123456789101112131415161718192021222324class jQuery &#123;    constructor(selector)&#123;        # Array.prototype.slice 方法将伪数组转为数组        let dom = Array.prototype.slice.call(document.querySelectorAll(selector))        let len = dom ? dom.length : 0                for ( let i = 0; i &lt; len; i++ ) &#123;            this [i]  = dom [i]        &#125;        this.length = len        this.selector = selector    &#125;    append (node) &#123;    &#125;    addClass (name) &#123;    &#125;    # 此处省略n个api...&#125;window.$ = function (selector) &#123;    return new jQuery(selector)&#125;\n\n面向对象的意义数据结构化\n","plink":"yibaobeiya.github.io/2019/10/14/js-面向对象/"},{"title":"JS 设计模式","date":"2019-10-12T02:57:12.535Z","updated":"2019-10-16T09:43:35.099Z","content":"概述js的设计模式总共有23种，总体来说设计模式分为三大类：\n1、创建型模式 共五种：工厂方法模式、抽象工厂模式、建造者模式、单例模式、原型模式。2、结构型模式，共七种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式。3、行为型模式，共十一种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式。\n常用的设计模式工厂方法模式、单例模式、适配器模式、组合模式、迭代子模式\n工厂方法模式介绍\n将 new 操作单独封装。\n遇到 new 时，就要考虑是否该使用工厂模式。\n\n示例\n你去购买汉堡，直接点餐、取餐，不会自己亲手做。\n商店要封装做汉堡的工作，做好直接给顾客。\n\n123456789101112131415161718192021class Product &#123;    constructor(name)&#123;        this.name = name;    &#125;,    init()&#123;    &#125;    buy()&#123;        return this.name;    &#125;&#125;# //工厂class Store &#123;    create(name)&#123;        return new Product(name)    &#125;&#125;const store = new Store();  const product = store.create('干脆面')product.buy()\n\n场景\njQuery 实例$(‘div’)\n\n\nReact.createElement\n\n1234567891011class Vnode(tag, attrs, children) &#123;    # 省略内部代码...&#125;React.createElement = function(tag, attrs, children)&#123;    return new Vnode(tag, attrs, children)&#125;# 调用React.createElement('div',null,    React.createElement('img',&#123;src:'header.png'&#125;)    React.createElement('h3',null,'h3标题就是我'))\n\n\nvue 异步组件\n\n1234567Vue.component('component-name',function(resolve, reject)&#123;    setTimeout(function()&#123;        resolve(&#123;            template : '&lt;div&gt;I am async!&lt;/div&gt;'        &#125;)    &#125;,1000)&#125;)\n\n单例模式介绍\n系统中被唯一使用\n一个类只能初始化一个实例\n\n示例\n登陆框\n\n123456789101112131415class SingleObject &#123;    login() &#123;        console.log('login...')    &#125;&#125;SingleObject.getInstance = (function()&#123;    let instance;    return function()&#123;        return instance?instance:instance = new SingleObject()    &#125;&#125;)();# 调用let obj1 = SingleObject.getInstance()let obj2 = SingleObject.getInstance()console.log(obj1 === obj2) //true\n\n\n购物车\n\n123function creat()&#123;    &#125;\n\n场景适配器模式123function creat()&#123;    &#125;\n\n组合模式123function creat()&#123;    &#125;\n\n迭代子模式123function creat()&#123;    &#125;","plink":"yibaobeiya.github.io/2019/10/12/设计模式/设计模式/"}]